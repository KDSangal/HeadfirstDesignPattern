# Head first design patterns

<table>
<th>
    <tr>
        <td>#</td>
        <td>Design pattern</td>
        <td>Definition</td>
    </tr>
</th>
<tr>
    <td>1</td>
    <td>Strategy</td>
    <td>
    The Strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.
    </td>
</tr>
<tr>
    <td>2</td>
    <td>Observer</td>
    <td>
        The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of it's dependents are notified and updated automatically
        </td>
</tr>
<tr>
    <td>3</td>
    <td>Decorator</td>
    <td>
        The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. 
    </td>
</tr>
<tr>
    <td>4</td>
    <td>Factory Method</td>
    <td>
        The Factory Method Pattern defines an interface for creating an object, but lets subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 
    </td>
</tr>

<tr>
    <td>5</td>
    <td>Singleton</td>
    <td>
        The Singleton Pattern ensures a class has only one instance, and provides a global point of access to it. 
    </td>
</tr>

<tr>
    <td>6</td>
    <td>Command</td>
    <td>
        The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations
    </td>
</tr>

<tr>
    <td>7.1</td>
    <td>Adapter</td>
    <td>
        The Adapter Pattern converts the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
    </td>
</tr>

<tr>
    <td>7.2</td>
    <td>Facade</td>
    <td>
        The Facade Pattern provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher level interface that makes the subsystem easier to use. 
    </td>
</tr>

<tr>
    <td>8</td>
    <td>Template Method</td>
    <td>
        The Template Method Pattern defines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redifine certain steps of an algorithm without changing the algorithm's structure. 
    </td>
</tr>

<tr>
    <td></td>
    <td></td>
    <td>
    template
    </td>
</tr>
</table>
